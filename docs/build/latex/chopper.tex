%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Chopper}
\date{Dec 01, 2021}
\release{0.0.1}
\author{Enflame}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Pass And Transforms}
\label{\detokenize{Pass_And_Transforms/index:pass-and-transforms}}\label{\detokenize{Pass_And_Transforms/index::doc}}

\section{CANCERConversionPasses}
\label{\detokenize{Pass_And_Transforms/index:cancerconversionpasses}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}convert\sphinxhyphen{}basicpy\sphinxhyphen{}to\sphinxhyphen{}std}}: Convert representable Basicpy ops to std}
\label{\detokenize{Pass_And_Transforms/index:convert-basicpy-to-std-convert-representable-basicpy-ops-to-std}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}convert\sphinxhyphen{}numpy\sphinxhyphen{}to\sphinxhyphen{}tcf}}: Convert the numpy dialect to supported TCF ops}
\label{\detokenize{Pass_And_Transforms/index:convert-numpy-to-tcf-convert-the-numpy-dialect-to-supported-tcf-ops}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}convert\sphinxhyphen{}tcf\sphinxhyphen{}to\sphinxhyphen{}linalg}}: Convert TCF to Linalg}
\label{\detokenize{Pass_And_Transforms/index:convert-tcf-to-linalg-convert-tcf-to-linalg}}
\sphinxAtStartPar
The intention is for this pass to convert mainly to linalg named ops.

\sphinxAtStartPar
Because linalg is at the “TCP” layer of abstraction, this pass has to
concern itself with generating guards for error cases. \#\#\#
\sphinxcode{\sphinxupquote{\sphinxhyphen{}convert\sphinxhyphen{}tcf\sphinxhyphen{}to\sphinxhyphen{}std}}: Convert TCF to Std \#\#\# \sphinxcode{\sphinxupquote{\sphinxhyphen{}convert\sphinxhyphen{}tcf\sphinxhyphen{}to\sphinxhyphen{}tcp}}:
Convert TCF to TCP


\section{RefBackendPasses}
\label{\detokenize{Pass_And_Transforms/index:refbackendpasses}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}lower\sphinxhyphen{}alloc\sphinxhyphen{}memref\sphinxhyphen{}ops}}: Lower AllocMemRefOp’s}
\label{\detokenize{Pass_And_Transforms/index:lower-alloc-memref-ops-lower-allocmemrefop-s}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}lower\sphinxhyphen{}to\sphinxhyphen{}refbackrt\sphinxhyphen{}abi}}: Lower constructs requiring runtime support to \sphinxstyleliteralintitle{\sphinxupquote{refbackrt}}}
\label{\detokenize{Pass_And_Transforms/index:lower-to-refbackrt-abi-lower-constructs-requiring-runtime-support-to-refbackrt}}
\sphinxAtStartPar
We have a specialized dialect \sphinxcode{\sphinxupquote{refbackrt}} which models our runtime’s
data structures, and function signatures (and presumably eventually,
other ABI boundaries like external calls if we ever support it) will be
converted.

\sphinxAtStartPar
The constructs requiring runtime support are: \sphinxhyphen{} function signatures /
module metadata \sphinxhyphen{} error handling \#\#\# \sphinxcode{\sphinxupquote{\sphinxhyphen{}refback\sphinxhyphen{}lower\sphinxhyphen{}to\sphinxhyphen{}llvm}}: Lower
everything to LLVM \#\#\# \sphinxcode{\sphinxupquote{\sphinxhyphen{}restricted\sphinxhyphen{}canonicalize}}: Canonicalize
operations This pass is the same as the regular \sphinxcode{\sphinxupquote{canonicalize}} pass,
but it only applies a restricted set of patterns.

\sphinxAtStartPar
This is useful when a particular canonicalization is actually needed for
correctness of a lowering flow. For such cases, running a restricted set
of canonicalizations makes it clearer which passes are needed for
correctness and which passes are “just optimizations”. This helps when
debugging miscompiles and other situations where the compiler is not
behaving as expected.


\subsubsection{Options}
\label{\detokenize{Pass_And_Transforms/index:options}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{included}\PYG{o}{\PYGZhy{}}\PYG{n}{dialects} \PYG{p}{:} \PYG{n}{Which} \PYG{n}{dialects} \PYG{n}{should} \PYG{n}{be} \PYG{n}{canonicalized}
\end{sphinxVerbatim}


\section{Transforms}
\label{\detokenize{Pass_And_Transforms/index:transforms}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}basicpy\sphinxhyphen{}type\sphinxhyphen{}inference}}: Performs function level type inference}
\label{\detokenize{Pass_And_Transforms/index:basicpy-type-inference-performs-function-level-type-inference}}

\section{CANCERNumpyTransforms}
\label{\detokenize{Pass_And_Transforms/index:cancernumpytransforms}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}numpy\sphinxhyphen{}array\sphinxhyphen{}to\sphinxhyphen{}tensor}}: Replace arrays with tensors where possible (optimization only).}
\label{\detokenize{Pass_And_Transforms/index:numpy-array-to-tensor-replace-arrays-with-tensors-where-possible-optimization-only}}
\sphinxAtStartPar
This pass is analogous to an SSA\sphinxhyphen{}formation pass in a traditional
compiler, with the added complication that arrays can alias each other
in interesting ways.

\sphinxAtStartPar
The current code doesn’t implement any fancy algorithm, and is intended
to be just sufficient for a first e2e spike. An algorithm inspired by
the SSA formation literature will need to be implemented.

\sphinxAtStartPar
Also, this pass doesn’t currently handle interprocedural rewriting (of
private functions), which is even more complex. \#\#\#
\sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy\sphinxhyphen{}public\sphinxhyphen{}functions\sphinxhyphen{}to\sphinxhyphen{}tensor}}: Converts public functions to
operate on tensors (instead of ndarray) \#\#\#
\sphinxcode{\sphinxupquote{\sphinxhyphen{}numpy\sphinxhyphen{}refine\sphinxhyphen{}public\sphinxhyphen{}return}}: Refine public return Refines types of
values return from public functions based on intraprocedural
information.

\sphinxAtStartPar
This pass effectively encodes an assumption by the pass pipeline author
that the public calling convention of the module can have its types
refined, without causing ABI mismatches. This is frequently true \textendash{} for
example, in many systems, \sphinxcode{\sphinxupquote{tensor\textless{}?x?xf32\textgreater{}}}, \sphinxcode{\sphinxupquote{tensor\textless{}3x3xf32\textgreater{}}} and
\sphinxcode{\sphinxupquote{tensor\textless{}*x!numpy.any\_dtype\textgreater{}}} are all the same data structure on
calling convention boundaries.

\sphinxAtStartPar
This pass is expected to run after shape refinement has occurred to
otherwise resolve shapes, and is currently mainly useful to convert
rank/dtype\sphinxhyphen{}erased function boundaries to ranked, dtyped code for
compiler backends.


\section{CANCERTCFTransforms}
\label{\detokenize{Pass_And_Transforms/index:cancertcftransforms}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}tcf\sphinxhyphen{}shape\sphinxhyphen{}refinement}}: Refines shapes of tensors}
\label{\detokenize{Pass_And_Transforms/index:tcf-shape-refinement-refines-shapes-of-tensors}}

\section{CANCERTCPTransforms}
\label{\detokenize{Pass_And_Transforms/index:cancertcptransforms}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{\sphinxhyphen{}tcp\sphinxhyphen{}bufferize}}: Bufferizes the tcp dialect}
\label{\detokenize{Pass_And_Transforms/index:tcp-bufferize-bufferizes-the-tcp-dialect}}

\chapter{Basicpy}
\label{\detokenize{Basicpy/index:basicpy}}\label{\detokenize{Basicpy/index::doc}}

\section{BasicpyDialect}
\label{\detokenize{Basicpy/index:basicpydialect}}



\section{BasicpyOps}
\label{\detokenize{Basicpy/index:basicpyops}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.as\_i1}} (::mlir::CANCER::Basicpy::AsI1Op)}
\label{\detokenize{Basicpy/index:basicpy-as-i1-mlir-cancer-basicpy-asi1op}}
\sphinxAtStartPar
Evaluates an input to an i1 predicate value

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.as\PYGZus{}i1` \PYGZdl{}operand attr\PYGZhy{}dict `:` type(\PYGZdl{}operand)
\end{sphinxVerbatim}

\sphinxAtStartPar
Applies the rules for interpreting a type as a boolean, returning an i1
indicating the truthiness of the operand. Since the output of this op is
intended to drive lower\sphinxhyphen{}level control flow, the i1 type is used (not the
user level BoolType).


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:operands}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:results}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
1\sphinxhyphen{}bit signless integer
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.binary\_compare}} (::mlir::CANCER::Basicpy::BinaryCompareOp)}
\label{\detokenize{Basicpy/index:basicpy-binary-compare-mlir-cancer-basicpy-binarycompareop}}
\sphinxAtStartPar
Performs a comparison between two operands

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.binary\PYGZus{}compare` \PYGZdl{}left \PYGZdl{}operation \PYGZdl{}right attr\PYGZhy{}dict `:` type(operands)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op performs only one step of a potentially multi\sphinxhyphen{}step short circuit
comparison. See:
\sphinxurl{https://docs.python.org/3/reference/expressions.html\#comparisons}


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:attributes}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operation}}
&
\sphinxAtStartPar
::mlir::StringAttr
&
\sphinxAtStartPar
Comparison operator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{left}}
&
\sphinxAtStartPar
any type
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{right}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id2}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Bool type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.binary\_expr}} (::mlir::CANCER::Basicpy::BinaryExprOp)}
\label{\detokenize{Basicpy/index:basicpy-binary-expr-mlir-cancer-basicpy-binaryexprop}}
\sphinxAtStartPar
Binary expression

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.binary\PYGZus{}expr` \PYGZdl{}left \PYGZdl{}operation \PYGZdl{}right attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
An expression between two operands as generated by the AST BinOp node.


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id3}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operation}}
&
\sphinxAtStartPar
::mlir::StringAttr
&
\sphinxAtStartPar
Operation for a binary expression
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id4}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{left}}
&
\sphinxAtStartPar
any type
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{right}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.bool\_cast}} (::mlir::CANCER::Basicpy::BoolCastOp)}
\label{\detokenize{Basicpy/index:basicpy-bool-cast-mlir-cancer-basicpy-boolcastop}}
\sphinxAtStartPar
Casts between BoolType and i1 (predicate value)

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.bool\PYGZus{}cast` \PYGZdl{}operand attr\PYGZhy{}dict `:` type(operands) `\PYGZhy{}\PYGZgt{}` type(results)
\end{sphinxVerbatim}

\sphinxAtStartPar
When interfacing with lower level dialect or progressively lowering the
Python BoolType away, it is often necessary to cast between it and i1,
which is used to represent bool\sphinxhyphen{}ness at lower levels.


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id6}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
Python bool or i1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id7}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Python bool or i1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.bool\_constant}} (::mlir::CANCER::Basicpy::BoolConstantOp)}
\label{\detokenize{Basicpy/index:basicpy-bool-constant-mlir-cancer-basicpy-boolconstantop}}
\sphinxAtStartPar
A boolean constant

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.bool\PYGZus{}constant` \PYGZdl{}value attr\PYGZhy{}dict
\end{sphinxVerbatim}

\sphinxAtStartPar
A constant of type !basicpy.BoolType that can take either an i1 value of
0 (False) or 1 (True).

\sphinxAtStartPar
Note that as in Python a BoolType can be thought of as an object,
whereas the corresponding i1 is a numeric type suitable for use in
contexts where storage format matters (or for interop with lower level
dialects).


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id8}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}
&
\sphinxAtStartPar
::mlir::IntegerAttr
&
\sphinxAtStartPar
1\sphinxhyphen{}bit signless integer attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id9}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Bool type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.build\_dict}} (::mlir::CANCER::Basicpy::BuildDictOp)}
\label{\detokenize{Basicpy/index:basicpy-build-dict-mlir-cancer-basicpy-builddictop}}
\sphinxAtStartPar
Builds an empty dict

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.build\PYGZus{}dict` attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op mirrors the CPython BUILD\_MAP op (note naming difference).

\sphinxAtStartPar
Note that as with CPython, this op only builds an empty dict; however,
it is reserved in the future for it to take variadic operands to
construct with a list of key/value pairs.


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id10}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Dict type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.build\_list}} (::mlir::CANCER::Basicpy::BuildListOp)}
\label{\detokenize{Basicpy/index:basicpy-build-list-mlir-cancer-basicpy-buildlistop}}
\sphinxAtStartPar
Builds a list from operands

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.build\PYGZus{}list` operands attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
Constructs a new list object from its operands.

\sphinxAtStartPar
TODO: Any allowable type can be expressed in lists; however, this should
be revisited once more of the dialect infrastructure is in place and
tightened up accordingly. At that time, appropriate constraints should
be added that both allow correct program representation and support
transformations to lower levels (i.e. allowing a wider set of types as
useful for conversions).


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id11}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elements}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id12}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
List type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.build\_tuple}} (::mlir::CANCER::Basicpy::BuildTupleOp)}
\label{\detokenize{Basicpy/index:basicpy-build-tuple-mlir-cancer-basicpy-buildtupleop}}
\sphinxAtStartPar
Builds a tuple from operands

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.build\PYGZus{}tuple` operands attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
Constructs a new tuple object from its operands.

\sphinxAtStartPar
TODO: Any allowable type can be expressed in lists; however, this should
be revisited once more of the dialect infrastructure is in place and
tightened up accordingly. At that time, appropriate constraints should
be added that both allow correct program representation and support
transformations to lower levels (i.e. allowing a wider set of types as
useful for conversions).


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id13}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{elements}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id14}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Tuple type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.bytes\_constant}} (::mlir::CANCER::Basicpy::BytesConstantOp)}
\label{\detokenize{Basicpy/index:basicpy-bytes-constant-mlir-cancer-basicpy-bytesconstantop}}
\sphinxAtStartPar
Constant bytes value

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.bytes\PYGZus{}constant` \PYGZdl{}value attr\PYGZhy{}dict
\end{sphinxVerbatim}

\sphinxAtStartPar
A bytes value of BytesType. The value is represented by a StringAttr.


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id15}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}
&
\sphinxAtStartPar
::mlir::StringAttr
&
\sphinxAtStartPar
string attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id16}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Bytes type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.exec\_discard}} (::mlir::CANCER::Basicpy::ExecDiscardOp)}
\label{\detokenize{Basicpy/index:basicpy-exec-discard-mlir-cancer-basicpy-execdiscardop}}
\sphinxAtStartPar
Terminator for an exec block

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.exec\PYGZus{}discard` operands attr\PYGZhy{}dict `:` type(operands)
\end{sphinxVerbatim}

\sphinxAtStartPar
Discards results and terminates an exec block.


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id17}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operands}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.exec}} (::mlir::CANCER::Basicpy::ExecOp)}
\label{\detokenize{Basicpy/index:basicpy-exec-mlir-cancer-basicpy-execop}}
\sphinxAtStartPar
Evaluates an expression being executed as a statement

\sphinxAtStartPar
The result is discarded. Typically expressions are no\sphinxhyphen{}side\sphinxhyphen{}effect and
can be re\sphinxhyphen{}ordered as needed. Embedding one in an exec op ensures that
its placement in program order is preserved.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.func\_template\_call}} (::mlir::CANCER::Basicpy::FuncTemplateCallOp)}
\label{\detokenize{Basicpy/index:basicpy-func-template-call-mlir-cancer-basicpy-functemplatecallop}}
\sphinxAtStartPar
Calls a function template

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.func\PYGZus{}template\PYGZus{}call` \PYGZdl{}callee `(` \PYGZdl{}args `)` `kw` \PYGZdl{}arg\PYGZus{}names attr\PYGZhy{}dict `:` functional\PYGZhy{}type(\PYGZdl{}args, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
Most function calls start with this generic calling op, which binds
symbolically to a func\_template. At this level, there are very few
semantics associated with the call, since, often, both types and the
specific concrete callee cannot be determined.

\sphinxAtStartPar
Per python calling conventions, all functions return one result, even if
None or a tuple (which may be syntactically unpacked to multiple
results).

\sphinxAtStartPar
If specified, the \sphinxcode{\sphinxupquote{argNames}} operand is right aligned to the list of
positional \sphinxcode{\sphinxupquote{args}}, representing arguments that are special or have
been passed with a keyword. The following arg names are special: ‘*’:
Indicates that the argument is a positional argument pack (must be the
first arg name, if present). ‘**’: Indicates that the argument is a
keyword argument pack (must be the last arg name, if present).


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id18}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{callee}}
&
\sphinxAtStartPar
::mlir::FlatSymbolRefAttr
&
\sphinxAtStartPar
flat symbol reference attribute
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{arg\_names}}
&
\sphinxAtStartPar
::mlir::ArrayAttr
&
\sphinxAtStartPar
string array attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id19}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{args}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id20}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.func\_template}} (::mlir::CANCER::Basicpy::FuncTemplateOp)}
\label{\detokenize{Basicpy/index:basicpy-func-template-mlir-cancer-basicpy-functemplateop}}
\sphinxAtStartPar
Group of multiple overload\sphinxhyphen{}resolved concrete functions

\sphinxAtStartPar
The outer func\_template op acts as a module that can contain named
concrete functions that are interpreted as overloads. If the function
signature is sufficient to disambiguate (i.e. with nothing more than
arity and MLIR argument types), then this is all that is needed.
However, in many cases, additional attributes will need to be specified
to further constrain types. The first matching function signature is
selected to satisfy a \sphinxcode{\sphinxupquote{func\_template\_call}} op.

\sphinxAtStartPar
TODO: Define this extended constraint matching.

\sphinxAtStartPar
Once a concrete function is selected as being applicable to a given
call, it will typically be instantiated as a standalone, unspecialized
function in the calling module (as a peer to the func\_template). This
function will be uniquely identified by concating the outer
func\_template’s symbol name, ‘\$’, and the concrete instance’s symbol
name.

\sphinxAtStartPar
Note that the function may still be unspecialized (in that it contains
UnknownType arguments/results), and type inference is expected to
further specialize/inline/constrain it.

\sphinxAtStartPar
By convention, func\_templates are named to avoid collision for various
uses: \sphinxhyphen{} Global function templates:
“\sphinxstylestrong{global:math:\textasciigrave{}python.qualified.name”   \sphinxhyphen{} Method names: “\_\_method\textasciigrave{}method\_name”
\sphinxhyphen{} Attribute getter:
“}getattrattr_name"   - Attribute setter: "__setattrattr\_name”

\sphinxAtStartPar
As in user\sphinxhyphen{}level python, for functions that bind to an instance, the
first argument must be a concrete type for the bound instance type. In
this way, there is one \sphinxcode{\sphinxupquote{func\_template}} for every unique member name
and the normal type constraints system is used to select the overload,
just as if it was a normal function call. It is left to utility routines
to merge libraries in a way that preserves this invariant.

\sphinxAtStartPar
TODO: This needs to be fleshed out more as some additional rules about
ordering and conflict resolution are likely needed to make this correct.

\sphinxAtStartPar
When extracting a program, it is typically necessary to create weak
references to specific python functions and correlate them back to a
named template defined here. Often times this can just be done
lexically, but to avoid fragility, any func\_template that correlates to
a python runtime function will have an additional attribute \sphinxcode{\sphinxupquote{py\_bind}}
that is an array of StringAttr qualified names to resolve and bind to in
the python runtime. In cases of divergence, the symbol name of the
template should be chosen just for uniqueness (not significance).

\sphinxAtStartPar
The qualified name format for \sphinxcode{\sphinxupquote{py\_bind}} attribute is:
package.name\#local.qualified.name


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.func\_template\_terminator}} (::mlir::CANCER::Basicpy::FuncTemplateTerminatorOp)}
\label{\detokenize{Basicpy/index:basicpy-func-template-terminator-mlir-cancer-basicpy-functemplateterminatorop}}
\sphinxAtStartPar
Terminator pseudo\sphinxhyphen{}op for the FuncTemplateOp


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.numeric\_constant}} (::mlir::CANCER::Basicpy::NumericConstantOp)}
\label{\detokenize{Basicpy/index:basicpy-numeric-constant-mlir-cancer-basicpy-numericconstantop}}
\sphinxAtStartPar
A constant from the Python3 numeric type hierarchy

\sphinxAtStartPar
Basicpy re\sphinxhyphen{}uses core MLIR types to represent the Python3 numeric type
hierarchy with the following mappings:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Python3 \sphinxcode{\sphinxupquote{int}} : In python, this type is signed, arbitrary precision
but in typical realizations, it maps to an MLIR \sphinxcode{\sphinxupquote{IntegerType}} of a
fixed bit\sphinxhyphen{}width (typically si64 if no further information is known).
In the future, there may be a real \sphinxcode{\sphinxupquote{Basicpy::IntType}} that retains
the true arbitrary precision nature, but this is deemed an
enhancement that does not obviate the need to infer physical, sized
types for many real\sphinxhyphen{}world cases. As such, the Basicpy numeric type
hierarchy will always include physical \sphinxcode{\sphinxupquote{IntegerType}}, if only to
enable progressive lowering and interop with cases where the precise
type is known.

\item {} 
\sphinxAtStartPar
Python3 \sphinxcode{\sphinxupquote{float}} : This is allowed to map to any legal floating
point type on the physical machine and is usually represented as a
double (f64). In MLIR, any \sphinxcode{\sphinxupquote{FloatType}} is allowed, which
facilitates progressive lowering and interop with cases where a more
precise type is known.

\item {} 
\sphinxAtStartPar
Python3 \sphinxcode{\sphinxupquote{complex}} : Maps to an MLIR \sphinxcode{\sphinxupquote{ComplexType}} with a
\sphinxcode{\sphinxupquote{FloatType}} elementType (note: in Python, complex numbers are
always defined with floating point components).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bool}} : See \sphinxcode{\sphinxupquote{bool\_constant}} for a constant (i1) \sphinxhyphen{}\textgreater{}
!basicpy.BoolType constant. This constant op is not used for
representing such bool values, even though from the Python
perspective, bool is part of the numeric hierarchy (the distinction
is really only necessary during promotion).

\end{itemize}


\subsection{Integer Signedness}
\label{\detokenize{Basicpy/index:integer-signedness}}
\sphinxAtStartPar
All \sphinxcode{\sphinxupquote{int}} values in Python are signed. However, there exist special
cases where libraries (i.e. struct packing and numpy arrays)
interoperate with unsigned values. As such, when mapping to MLIR, Python
integer types are represented as either signed or unsigned
\sphinxcode{\sphinxupquote{IntegerType}} types and can be lowered to signless integers as
appropriate (typically during realization of arithmetic expressions
where the choice is meaningful). Since it is not known at the outset
when in lowering this information is safe to discard this
\sphinxcode{\sphinxupquote{numeric\_constant}} op accepts any signedness.


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id21}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}
&
\sphinxAtStartPar
::mlir::Attribute
&
\sphinxAtStartPar
any attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id22}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
«unnamed»
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.singleton}} (::mlir::CANCER::Basicpy::SingletonOp)}
\label{\detokenize{Basicpy/index:basicpy-singleton-mlir-cancer-basicpy-singletonop}}
\sphinxAtStartPar
Constant value for a singleton type

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.singleton` attr\PYGZhy{}dict `:` type(\PYGZdl{}result)
\end{sphinxVerbatim}

\sphinxAtStartPar
Some types only have a single possible value, represented by the
SingletonAttr. This op allows creating constants of these types.


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id23}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
None type or Ellipsis type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.slot\_object\_get}} (::mlir::CANCER::Basicpy::SlotObjectGetOp)}
\label{\detokenize{Basicpy/index:basicpy-slot-object-get-mlir-cancer-basicpy-slotobjectgetop}}
\sphinxAtStartPar
Gets a slot from a slot object

\sphinxAtStartPar
Gets a slot from a SlotObject.

\sphinxAtStartPar
Example: \%0 = basicpy.slot\_object\_make … \%1 =
basicpy.slot\_object\_get \%0{[}1{]} : !basicpy.SlotObject\textless{}…\textgreater{}


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id24}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{index}}
&
\sphinxAtStartPar
::mlir::IntegerAttr
&
\sphinxAtStartPar
index attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id25}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{object}}
&
\sphinxAtStartPar
Slot object
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id26}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.slot\_object\_make}} (::mlir::CANCER::Basicpy::SlotObjectMakeOp)}
\label{\detokenize{Basicpy/index:basicpy-slot-object-make-mlir-cancer-basicpy-slotobjectmakeop}}
\sphinxAtStartPar
Creates an instance of a SlotObject type

\sphinxAtStartPar
SlotObjects are typically instances of built\sphinxhyphen{}in classes that have a
fixed number of slots. Unlike in standard python, the types of each slot
are tracked.

\sphinxAtStartPar
This op has a custom assembly form which can be used when valid that
omits the operand types (since they are equal to the types in the
returned slot object). Example: \%0 = basicpy.singleton :
!basicpy.NoneType \%1 = basicpy.slot\_object\_make(\%0) \sphinxhyphen{}\textgreater{}
!basicpy.SlotObject


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id27}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slots}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id28}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
Slot object
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.str\_constant}} (::mlir::CANCER::Basicpy::StrConstantOp)}
\label{\detokenize{Basicpy/index:basicpy-str-constant-mlir-cancer-basicpy-strconstantop}}
\sphinxAtStartPar
Constant string value

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.str\PYGZus{}constant` \PYGZdl{}value attr\PYGZhy{}dict
\end{sphinxVerbatim}

\sphinxAtStartPar
A string value of StrType. The value is represented by a StringAttr that
is UTF\sphinxhyphen{}8 encoded.


\subsubsection{Attributes:}
\label{\detokenize{Basicpy/index:id29}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value}}
&
\sphinxAtStartPar
::mlir::StringAttr
&
\sphinxAtStartPar
string attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id30}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
String type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{basicpy.unknown\_cast}} (::mlir::CANCER::Basicpy::UnknownCastOp)}
\label{\detokenize{Basicpy/index:basicpy-unknown-cast-mlir-cancer-basicpy-unknowncastop}}
\sphinxAtStartPar
Casts to and from the UnknownType

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `basicpy.unknown\PYGZus{}cast` operands attr\PYGZhy{}dict `:` type(operands) `\PYGZhy{}\PYGZgt{}` type(results)
\end{sphinxVerbatim}


\subsubsection{Operands:}
\label{\detokenize{Basicpy/index:id31}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Basicpy/index:id32}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
any type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Numpy}
\label{\detokenize{Numpy/index:numpy}}\label{\detokenize{Numpy/index::doc}}

\section{NumpyOps}
\label{\detokenize{Numpy/index:numpyops}}



\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.builtin\_ufunc\_call}} (::mlir::CANCER::Numpy::BuiltinUfuncCallOp)}
\label{\detokenize{Numpy/index:numpy-builtin-ufunc-call-mlir-cancer-numpy-builtinufunccallop}}
\sphinxAtStartPar
A \sphinxstylestrong{call} operation on a named/builtin ufunc

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.builtin\PYGZus{}ufunc\PYGZus{}call` `\PYGZlt{}` \PYGZdl{}qualified\PYGZus{}name `\PYGZgt{}` `(` operands `)` attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, results)
\end{sphinxVerbatim}

\sphinxAtStartPar
Simple ufunc call semantics for builtin ufuncs with none of the advanced
arguments specified.

\sphinxAtStartPar
Note that without the \sphinxcode{\sphinxupquote{out=}} parameter, ufunc call operations (unlike
others like \sphinxcode{\sphinxupquote{at}}) are defined purely in the value domain and do not
alias. As such, they operate on tensors, not ndarray.


\subsubsection{Attributes:}
\label{\detokenize{Numpy/index:attributes}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Attribute
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MLIR Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qualified\_name}}
&
\sphinxAtStartPar
::mlir::StringAttr
&
\sphinxAtStartPar
string attribute
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:operands}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inputs}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:results}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{output}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.copy\_to\_tensor}} (::mlir::CANCER::Numpy::CopyToTensorOp)}
\label{\detokenize{Numpy/index:numpy-copy-to-tensor-mlir-cancer-numpy-copytotensorop}}
\sphinxAtStartPar
Copies an ndarray, yielding a value\sphinxhyphen{}typed tensor.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.copy\PYGZus{}to\PYGZus{}tensor` \PYGZdl{}source attr\PYGZhy{}dict `:` functional\PYGZhy{}type(\PYGZdl{}source, \PYGZdl{}dest)
\end{sphinxVerbatim}

\sphinxAtStartPar
The semantics of this operation connote a copy of the data in the source
ndarray, producing a destination value that will have the value in the
ndarray at the point of the copy. Of course, downstream transformations
are free to rearrange things to elide the copy or otherwise eliminate
the need for it.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{source}}
&
\sphinxAtStartPar
ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id2}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dest}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.create\_array\_from\_tensor}} (::mlir::CANCER::Numpy::CreateArrayFromTensorOp)}
\label{\detokenize{Numpy/index:numpy-create-array-from-tensor-mlir-cancer-numpy-createarrayfromtensorop}}
\sphinxAtStartPar
Creates an ndarray from a tensor.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.create\PYGZus{}array\PYGZus{}from\PYGZus{}tensor` \PYGZdl{}source attr\PYGZhy{}dict `:` functional\PYGZhy{}type(\PYGZdl{}source, \PYGZdl{}dest)
\end{sphinxVerbatim}

\sphinxAtStartPar
Creates a new ndarray that will contain the data of the given tensor.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id3}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{source}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id4}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dest}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.dot}} (::mlir::CANCER::Numpy::DotOp)}
\label{\detokenize{Numpy/index:numpy-dot-mlir-cancer-numpy-dotop}}
\sphinxAtStartPar
Represents the \sphinxcode{\sphinxupquote{numpy.dot}} operator

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.dot` operands attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, \PYGZdl{}output)
\end{sphinxVerbatim}

\sphinxAtStartPar
See: \sphinxurl{https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html}


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id5}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id6}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{output}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.get\_slice}} (::mlir::CANCER::Numpy::GetSliceOp)}
\label{\detokenize{Numpy/index:numpy-get-slice-mlir-cancer-numpy-getsliceop}}
\sphinxAtStartPar
Gets a slice of an array

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.get\PYGZus{}slice` operands attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, \PYGZdl{}result)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op encapsulates all forms of indexing into an array by taking a
variable number of \sphinxcode{\sphinxupquote{slice}} arguments, each of which represents a
single entry in a generalized indexing\sphinxhyphen{}tuple. Once full type inference
has been performed, there should be sufficient static information to
determine the exact slice semantics solely by the signature of types of
the \sphinxcode{\sphinxupquote{slice}} arguments.

\sphinxAtStartPar
Note that there is a more general form of this op that is generally
needed for AST extraction that takes a variable length \sphinxcode{\sphinxupquote{tuple}} instead
of a static list of arguments. It is expected that during type
refinement most such uses should degenerate to this static variant.

\sphinxAtStartPar
Per numpy semantics, many forms of slice return a view instead of a
copy, and determining the exact form requires additional analysis.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id7}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{slice\_elements}}
&
\sphinxAtStartPar
types that are legal elements of a \sphinxstylestrong{getitem} tuple operating on arrays
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id8}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.narrow}} (::mlir::CANCER::Numpy::NarrowOp)}
\label{\detokenize{Numpy/index:numpy-narrow-mlir-cancer-numpy-narrowop}}
\sphinxAtStartPar
Narrows an array to a known type at boundaries.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.narrow` \PYGZdl{}operand attr\PYGZhy{}dict `:` functional\PYGZhy{}type(\PYGZdl{}operand, \PYGZdl{}result)
\end{sphinxVerbatim}

\sphinxAtStartPar
During tracing, specific data types are often unknown. This op
generically narrows from an unknown to a known data type at boundaries.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id9}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id10}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.overwrite\_array}} (::mlir::CANCER::Numpy::OverwriteArrayOp)}
\label{\detokenize{Numpy/index:numpy-overwrite-array-mlir-cancer-numpy-overwritearrayop}}
\sphinxAtStartPar
Ovewrite the contents of array with a tensor.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.overwrite\PYGZus{}array` \PYGZdl{}tensor `overwrites` \PYGZdl{}array attr\PYGZhy{}dict `:` type(\PYGZdl{}tensor) `,` type(\PYGZdl{}array)
\end{sphinxVerbatim}

\sphinxAtStartPar
Replaces the contents of \sphinxcode{\sphinxupquote{array}} with corresponding values from
\sphinxcode{\sphinxupquote{tensor}}.

\sphinxAtStartPar
Immediately after this op has completed, indexing \sphinxcode{\sphinxupquote{array}} will result
in identical values as indexing into \sphinxcode{\sphinxupquote{tensor}}. Of course, later ops
might mutate \sphinxcode{\sphinxupquote{array}}, so this relationship need not hold for the
entire program.

\sphinxAtStartPar
This op has undefined behavior if the tensor and array have different
shapes or dtypes.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id11}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tensor}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{array}}
&
\sphinxAtStartPar
ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.static\_info\_cast}} (::mlir::CANCER::Numpy::StaticInfoCastOp)}
\label{\detokenize{Numpy/index:numpy-static-info-cast-mlir-cancer-numpy-staticinfocastop}}
\sphinxAtStartPar
Adds/removes static information from an array type.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.static\PYGZus{}info\PYGZus{}cast` \PYGZdl{}operand attr\PYGZhy{}dict `:` type(\PYGZdl{}operand) `to` type(\PYGZdl{}result)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op does not imply any runtime code. Semantically it is an identity
function.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id12}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id13}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.tensor\_static\_info\_cast}} (::mlir::CANCER::Numpy::TensorStaticInfoCastOp)}
\label{\detokenize{Numpy/index:numpy-tensor-static-info-cast-mlir-cancer-numpy-tensorstaticinfocastop}}
\sphinxAtStartPar
Adds/removes static information from a tensor type.

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.tensor\PYGZus{}static\PYGZus{}info\PYGZus{}cast` \PYGZdl{}operand attr\PYGZhy{}dict `:` type(\PYGZdl{}operand) `to` type(\PYGZdl{}result)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op does not imply any runtime code. Semantically it is an identity
function.

\sphinxAtStartPar
Unlike \sphinxcode{\sphinxupquote{tensor.cast}}, this op allows changing dtype, following the
rules of numpy arrays where no runtime code is implied. In particular,
\sphinxcode{\sphinxupquote{!numpy.any\_dtype}} is compatible with all other element types, but
otherwise the element types must be the same. An element type of
\sphinxcode{\sphinxupquote{!numpy.any\_dtype}} represents the absence of static knowledge of the
dtype. It does not itself represent a concrete runtime element type.


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id14}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{operand}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id15}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{result}}
&
\sphinxAtStartPar
tensor of any type values
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{numpy.transpose}} (::mlir::CANCER::Numpy::TransposeOp)}
\label{\detokenize{Numpy/index:numpy-transpose-mlir-cancer-numpy-transposeop}}
\sphinxAtStartPar
Represents the \sphinxcode{\sphinxupquote{numpy.transpose}} op with no permutation specified

\sphinxAtStartPar
Syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
operation ::= `numpy.transpose` operands attr\PYGZhy{}dict `:` functional\PYGZhy{}type(operands, \PYGZdl{}output)
\end{sphinxVerbatim}

\sphinxAtStartPar
This op is equivalent to calling \sphinxcode{\sphinxupquote{numpy.transpose(arr)}}, which
reverses the axes of the array. It is separate from the explicit form
because it is not always possible to locallly infer an appropriate axis
transform at the point of declaration.

\sphinxAtStartPar
See:
\sphinxurl{https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html}


\subsubsection{Operands:}
\label{\detokenize{Numpy/index:id16}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Results:}
\label{\detokenize{Numpy/index:id17}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Result
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{output}}
&
\sphinxAtStartPar
tensor of any type values or ndarray type
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{NumpyDialect}
\label{\detokenize{Numpy/index:numpydialect}}



\chapter{cancer\_frontend}
\label{\detokenize{modules:cancer-frontend}}\label{\detokenize{modules::doc}}

\section{cancer\_frontend package}
\label{\detokenize{cancer_frontend:cancer-frontend-package}}\label{\detokenize{cancer_frontend::doc}}

\subsection{Subpackages}
\label{\detokenize{cancer_frontend:subpackages}}

\subsubsection{cancer\_frontend.numpy package}
\label{\detokenize{cancer_frontend.numpy:cancer-frontend-numpy-package}}\label{\detokenize{cancer_frontend.numpy::doc}}

\paragraph{Module contents}
\label{\detokenize{cancer_frontend.numpy:module-contents}}

\subsubsection{cancer\_frontend.python package}
\label{\detokenize{cancer_frontend.python:cancer-frontend-python-package}}\label{\detokenize{cancer_frontend.python::doc}}

\paragraph{Submodules}
\label{\detokenize{cancer_frontend.python:submodules}}

\paragraph{cancer\_frontend.python.python\_jit\_runner module}
\label{\detokenize{cancer_frontend.python:module-cancer_frontend.python.python_jit_runner}}\label{\detokenize{cancer_frontend.python:cancer-frontend-python-python-jit-runner-module}}\index{module@\spxentry{module}!cancer\_frontend.python.python\_jit\_runner@\spxentry{cancer\_frontend.python.python\_jit\_runner}}\index{cancer\_frontend.python.python\_jit\_runner@\spxentry{cancer\_frontend.python.python\_jit\_runner}!module@\spxentry{module}}
\sphinxAtStartPar
Contains jit runner class for compilation and execution
\index{PythonRunner (class in cancer\_frontend.python.python\_jit\_runner)@\spxentry{PythonRunner}\spxextra{class in cancer\_frontend.python.python\_jit\_runner}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{cancer\_frontend.python.python\_jit\_runner.}}\sphinxbfcode{\sphinxupquote{PythonRunner}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
PythonRunner class that is a compiler supports jit functionalities for numpy DSL.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns the instance of this class

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner}]{\sphinxcrossref{PythonRunner}}}

\end{description}\end{quote}
\index{dump\_mlir() (cancer\_frontend.python.python\_jit\_runner.PythonRunner method)@\spxentry{dump\_mlir()}\spxextra{cancer\_frontend.python.python\_jit\_runner.PythonRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner.dump_mlir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_mlir}}}{\emph{\DUrole{n}{\_ast}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{mlir.astnodes.Node}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{dump\_python() (cancer\_frontend.python.python\_jit\_runner.PythonRunner method)@\spxentry{dump\_python()}\spxextra{cancer\_frontend.python.python\_jit\_runner.PythonRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner.dump_python}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_python}}}{\emph{\DUrole{n}{\_ast}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{\_ast.AST}}}{{ $\rightarrow$ str}}
\end{fulllineitems}

\index{parse\_mlir() (cancer\_frontend.python.python\_jit\_runner.PythonRunner method)@\spxentry{parse\_mlir()}\spxextra{cancer\_frontend.python.python\_jit\_runner.PythonRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner.parse_mlir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_mlir}}}{\emph{\DUrole{n}{code\_path}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ mlir.astnodes.Node}}
\sphinxAtStartPar
Parses the code by providing its path
:param

\end{fulllineitems}

\index{parse\_python() (cancer\_frontend.python.python\_jit\_runner.PythonRunner method)@\spxentry{parse\_python()}\spxextra{cancer\_frontend.python.python\_jit\_runner.PythonRunner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.python:cancer_frontend.python.python_jit_runner.PythonRunner.parse_python}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_python}}}{\emph{\DUrole{n}{func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable}}}{{ $\rightarrow$ \_ast.AST}}
\sphinxAtStartPar
Parses the code by providing its path
:param

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{cancer_frontend.python:module-cancer_frontend.python}}\label{\detokenize{cancer_frontend.python:module-contents}}\index{module@\spxentry{module}!cancer\_frontend.python@\spxentry{cancer\_frontend.python}}\index{cancer\_frontend.python@\spxentry{cancer\_frontend.python}!module@\spxentry{module}}

\subsubsection{cancer\_frontend.scaffold package}
\label{\detokenize{cancer_frontend.scaffold:cancer-frontend-scaffold-package}}\label{\detokenize{cancer_frontend.scaffold::doc}}

\paragraph{Subpackages}
\label{\detokenize{cancer_frontend.scaffold:subpackages}}

\subparagraph{cancer\_frontend.scaffold.mlir\_dialects package}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:cancer-frontend-scaffold-mlir-dialects-package}}\label{\detokenize{cancer_frontend.scaffold.mlir_dialects::doc}}

\subparagraph{Submodules}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:submodules}}

\subparagraph{cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo module}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:module-cancer_frontend.scaffold.mlir_dialects.dialect_demo}}\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:cancer-frontend-scaffold-mlir-dialects-dialect-demo-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo}}\index{cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo}!module@\spxentry{module}}
\sphinxAtStartPar
Dialect classes that create and custom dialect as example.


\subparagraph{cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative module}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:module-cancer_frontend.scaffold.mlir_dialects.dialect_pynative}}\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:cancer-frontend-scaffold-mlir-dialects-dialect-pynative-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative}}\index{cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative}!module@\spxentry{module}}
\sphinxAtStartPar
Implemented classes of NativePython Dialect.


\subparagraph{cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf module}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:module-cancer_frontend.scaffold.mlir_dialects.dialect_tcf}}\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:cancer-frontend-scaffold-mlir-dialects-dialect-tcf-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf}}\index{cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf@\spxentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf}!module@\spxentry{module}}
\sphinxAtStartPar
Implemented classes of Tensor Computation Flow Dialect.


\subparagraph{Module contents}
\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:module-cancer_frontend.scaffold.mlir_dialects}}\label{\detokenize{cancer_frontend.scaffold.mlir_dialects:module-contents}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.mlir\_dialects@\spxentry{cancer\_frontend.scaffold.mlir\_dialects}}\index{cancer\_frontend.scaffold.mlir\_dialects@\spxentry{cancer\_frontend.scaffold.mlir\_dialects}!module@\spxentry{module}}

\subparagraph{cancer\_frontend.scaffold.utils package}
\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-package}}\label{\detokenize{cancer_frontend.scaffold.utils::doc}}

\subparagraph{Submodules}
\label{\detokenize{cancer_frontend.scaffold.utils:submodules}}

\subparagraph{cancer\_frontend.scaffold.utils.class\_utils module}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils.class_utils}}\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-class-utils-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils.class\_utils@\spxentry{cancer\_frontend.scaffold.utils.class\_utils}}\index{cancer\_frontend.scaffold.utils.class\_utils@\spxentry{cancer\_frontend.scaffold.utils.class\_utils}!module@\spxentry{module}}\index{classproperty (class in cancer\_frontend.scaffold.utils.class\_utils)@\spxentry{classproperty}\spxextra{class in cancer\_frontend.scaffold.utils.class\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.class_utils.classproperty}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.class\_utils.}}\sphinxbfcode{\sphinxupquote{classproperty}}}{\emph{\DUrole{n}{f}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
@classmethod+@property

\end{fulllineitems}

\index{memoized\_classproperty (class in cancer\_frontend.scaffold.utils.class\_utils)@\spxentry{memoized\_classproperty}\spxextra{class in cancer\_frontend.scaffold.utils.class\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.class_utils.memoized_classproperty}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.class\_utils.}}\sphinxbfcode{\sphinxupquote{memoized\_classproperty}}}{\emph{\DUrole{n}{f}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
@classmethod+@property

\end{fulllineitems}



\subparagraph{cancer\_frontend.scaffold.utils.display\_util module}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils.display_util}}\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-display-util-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils.display\_util@\spxentry{cancer\_frontend.scaffold.utils.display\_util}}\index{cancer\_frontend.scaffold.utils.display\_util@\spxentry{cancer\_frontend.scaffold.utils.display\_util}!module@\spxentry{module}}\index{ColorPalette (class in cancer\_frontend.scaffold.utils.display\_util)@\spxentry{ColorPalette}\spxextra{class in cancer\_frontend.scaffold.utils.display\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.display_util.ColorPalette}}\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.display\_util.}}\sphinxbfcode{\sphinxupquote{ColorPalette}}}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}
\index{ENDC (cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute)@\spxentry{ENDC}\spxextra{cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.display_util.ColorPalette.ENDC}}\pysigline{\sphinxbfcode{\sphinxupquote{ENDC}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}\textbackslash{}x1b{[}0m\textquotesingle{}}}}
\end{fulllineitems}

\index{FAIL (cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute)@\spxentry{FAIL}\spxextra{cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.display_util.ColorPalette.FAIL}}\pysigline{\sphinxbfcode{\sphinxupquote{FAIL}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}\textbackslash{}x1b{[}91m\textquotesingle{}}}}
\end{fulllineitems}

\index{HEADER (cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute)@\spxentry{HEADER}\spxextra{cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.display_util.ColorPalette.HEADER}}\pysigline{\sphinxbfcode{\sphinxupquote{HEADER}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}\textbackslash{}x1b{[}95m\textquotesingle{}}}}
\end{fulllineitems}

\index{WARNING (cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute)@\spxentry{WARNING}\spxextra{cancer\_frontend.scaffold.utils.display\_util.ColorPalette attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.display_util.ColorPalette.WARNING}}\pysigline{\sphinxbfcode{\sphinxupquote{WARNING}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textquotesingle{}\textbackslash{}x1b{[}93m\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}



\subparagraph{cancer\_frontend.scaffold.utils.file\_util module}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils.file_util}}\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-file-util-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils.file\_util@\spxentry{cancer\_frontend.scaffold.utils.file\_util}}\index{cancer\_frontend.scaffold.utils.file\_util@\spxentry{cancer\_frontend.scaffold.utils.file\_util}!module@\spxentry{module}}\index{dump\_to\_file() (in module cancer\_frontend.scaffold.utils.file\_util)@\spxentry{dump\_to\_file()}\spxextra{in module cancer\_frontend.scaffold.utils.file\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.file_util.dump_to_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.file\_util.}}\sphinxbfcode{\sphinxupquote{dump\_to\_file}}}{}{}
\end{fulllineitems}

\index{read\_src() (in module cancer\_frontend.scaffold.utils.file\_util)@\spxentry{read\_src()}\spxextra{in module cancer\_frontend.scaffold.utils.file\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.file_util.read_src}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.file\_util.}}\sphinxbfcode{\sphinxupquote{read\_src}}}{\emph{\DUrole{n}{filename}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{basestring}}}{{ $\rightarrow$ basestring}}
\end{fulllineitems}



\subparagraph{cancer\_frontend.scaffold.utils.import\_util module}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils.import_util}}\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-import-util-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils.import\_util@\spxentry{cancer\_frontend.scaffold.utils.import\_util}}\index{cancer\_frontend.scaffold.utils.import\_util@\spxentry{cancer\_frontend.scaffold.utils.import\_util}!module@\spxentry{module}}\index{get\_python\_library() (in module cancer\_frontend.scaffold.utils.import\_util)@\spxentry{get\_python\_library()}\spxextra{in module cancer\_frontend.scaffold.utils.import\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.import_util.get_python_library}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.import\_util.}}\sphinxbfcode{\sphinxupquote{get\_python\_library}}}{}{}
\end{fulllineitems}

\index{get\_python\_methods() (in module cancer\_frontend.scaffold.utils.import\_util)@\spxentry{get\_python\_methods()}\spxextra{in module cancer\_frontend.scaffold.utils.import\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.import_util.get_python_methods}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.import\_util.}}\sphinxbfcode{\sphinxupquote{get\_python\_methods}}}{\emph{\DUrole{n}{module}}}{}
\end{fulllineitems}

\index{wraps() (in module cancer\_frontend.scaffold.utils.import\_util)@\spxentry{wraps()}\spxextra{in module cancer\_frontend.scaffold.utils.import\_util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.import_util.wraps}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.import\_util.}}\sphinxbfcode{\sphinxupquote{wraps}}}{\emph{\DUrole{n}{wrapped}}, \emph{\DUrole{n}{assigned}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}\_\_module\_\_\textquotesingle{}, \textquotesingle{}\_\_name\_\_\textquotesingle{}, \textquotesingle{}\_\_qualname\_\_\textquotesingle{}, \textquotesingle{}\_\_doc\_\_\textquotesingle{}, \textquotesingle{}\_\_annotations\_\_\textquotesingle{})}}, \emph{\DUrole{n}{updated}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}\_\_dict\_\_\textquotesingle{},)}}}{}
\sphinxAtStartPar
Decorator factory to apply update\_wrapper() to a wrapper function

\sphinxAtStartPar
Returns a decorator that invokes update\_wrapper() with the decorated
function as the wrapper argument and the arguments to wraps() as the
remaining arguments. Default arguments are as for update\_wrapper().
This is a convenience function to simplify applying partial() to
update\_wrapper().

\end{fulllineitems}



\subparagraph{cancer\_frontend.scaffold.utils.json\_parser module}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils.json_parser}}\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-json-parser-module}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils.json\_parser@\spxentry{cancer\_frontend.scaffold.utils.json\_parser}}\index{cancer\_frontend.scaffold.utils.json\_parser@\spxentry{cancer\_frontend.scaffold.utils.json\_parser}!module@\spxentry{module}}

\subparagraph{Simple JSON Parser}
\label{\detokenize{cancer_frontend.scaffold.utils:simple-json-parser}}
\sphinxAtStartPar
The code is short and clear, and outperforms every other parser (that’s written in Python).
For an explanation, check out the JSON parser tutorial at /docs/json\_tutorial.md
(this is here for use by the other examples)
\index{TreeToJson (class in cancer\_frontend.scaffold.utils.json\_parser)@\spxentry{TreeToJson}\spxextra{class in cancer\_frontend.scaffold.utils.json\_parser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{cancer\_frontend.scaffold.utils.json\_parser.}}\sphinxbfcode{\sphinxupquote{TreeToJson}}}{\emph{\DUrole{n}{visit\_tokens}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{lark.visitors.Transformer}}
\index{array (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute)@\spxentry{array}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.array}}\pysigline{\sphinxbfcode{\sphinxupquote{array}}}
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{list}}

\end{fulllineitems}

\index{false() (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method)@\spxentry{false()}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.false}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{false}}}{\emph{\DUrole{n}{\_}}}{}
\end{fulllineitems}

\index{null() (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method)@\spxentry{null()}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.null}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{null}}}{\emph{\DUrole{n}{\_}}}{}
\end{fulllineitems}

\index{number (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute)@\spxentry{number}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.number}}\pysigline{\sphinxbfcode{\sphinxupquote{number}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{  }\DUrole{p}{=}\DUrole{w}{  }\textless{}function float\textgreater{}}}}
\end{fulllineitems}

\index{object (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute)@\spxentry{object}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.object}}\pysigline{\sphinxbfcode{\sphinxupquote{object}}}
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{dict}}

\end{fulllineitems}

\index{pair (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute)@\spxentry{pair}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.pair}}\pysigline{\sphinxbfcode{\sphinxupquote{pair}}}
\sphinxAtStartPar
alias of \sphinxcode{\sphinxupquote{tuple}}

\end{fulllineitems}

\index{string() (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method)@\spxentry{string()}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{string}}}{\emph{\DUrole{n}{s}}}{}
\end{fulllineitems}

\index{true() (cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method)@\spxentry{true()}\spxextra{cancer\_frontend.scaffold.utils.json\_parser.TreeToJson method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cancer_frontend.scaffold.utils:cancer_frontend.scaffold.utils.json_parser.TreeToJson.true}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{true}}}{\emph{\DUrole{n}{\_}}}{}
\end{fulllineitems}


\end{fulllineitems}



\subparagraph{cancer\_frontend.scaffold.utils.json\_parser\_test module}
\label{\detokenize{cancer_frontend.scaffold.utils:cancer-frontend-scaffold-utils-json-parser-test-module}}

\subparagraph{Module contents}
\label{\detokenize{cancer_frontend.scaffold.utils:module-cancer_frontend.scaffold.utils}}\label{\detokenize{cancer_frontend.scaffold.utils:module-contents}}\index{module@\spxentry{module}!cancer\_frontend.scaffold.utils@\spxentry{cancer\_frontend.scaffold.utils}}\index{cancer\_frontend.scaffold.utils@\spxentry{cancer\_frontend.scaffold.utils}!module@\spxentry{module}}

\paragraph{Module contents}
\label{\detokenize{cancer_frontend.scaffold:module-cancer_frontend.scaffold}}\label{\detokenize{cancer_frontend.scaffold:module-contents}}\index{module@\spxentry{module}!cancer\_frontend.scaffold@\spxentry{cancer\_frontend.scaffold}}\index{cancer\_frontend.scaffold@\spxentry{cancer\_frontend.scaffold}!module@\spxentry{module}}

\subsubsection{cancer\_frontend.torch package}
\label{\detokenize{cancer_frontend.torch:cancer-frontend-torch-package}}\label{\detokenize{cancer_frontend.torch::doc}}

\paragraph{Module contents}
\label{\detokenize{cancer_frontend.torch:module-cancer_frontend.torch}}\label{\detokenize{cancer_frontend.torch:module-contents}}\index{module@\spxentry{module}!cancer\_frontend.torch@\spxentry{cancer\_frontend.torch}}\index{cancer\_frontend.torch@\spxentry{cancer\_frontend.torch}!module@\spxentry{module}}

\subsection{Module contents}
\label{\detokenize{cancer_frontend:module-cancer_frontend}}\label{\detokenize{cancer_frontend:module-contents}}\index{module@\spxentry{module}!cancer\_frontend@\spxentry{cancer\_frontend}}\index{cancer\_frontend@\spxentry{cancer\_frontend}!module@\spxentry{module}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{cancer\_frontend}\sphinxstyleindexpageref{cancer_frontend:\detokenize{module-cancer_frontend}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.python}\sphinxstyleindexpageref{cancer_frontend.python:\detokenize{module-cancer_frontend.python}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.python.python\_jit\_runner}\sphinxstyleindexpageref{cancer_frontend.python:\detokenize{module-cancer_frontend.python.python_jit_runner}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold}\sphinxstyleindexpageref{cancer_frontend.scaffold:\detokenize{module-cancer_frontend.scaffold}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.mlir\_dialects}\sphinxstyleindexpageref{cancer_frontend.scaffold.mlir_dialects:\detokenize{module-cancer_frontend.scaffold.mlir_dialects}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_demo}\sphinxstyleindexpageref{cancer_frontend.scaffold.mlir_dialects:\detokenize{module-cancer_frontend.scaffold.mlir_dialects.dialect_demo}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_pynative}\sphinxstyleindexpageref{cancer_frontend.scaffold.mlir_dialects:\detokenize{module-cancer_frontend.scaffold.mlir_dialects.dialect_pynative}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.mlir\_dialects.dialect\_tcf}\sphinxstyleindexpageref{cancer_frontend.scaffold.mlir_dialects:\detokenize{module-cancer_frontend.scaffold.mlir_dialects.dialect_tcf}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils.class\_utils}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils.class_utils}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils.display\_util}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils.display_util}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils.file\_util}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils.file_util}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils.import\_util}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils.import_util}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.scaffold.utils.json\_parser}\sphinxstyleindexpageref{cancer_frontend.scaffold.utils:\detokenize{module-cancer_frontend.scaffold.utils.json_parser}}
\item\relax\sphinxstyleindexentry{cancer\_frontend.torch}\sphinxstyleindexpageref{cancer_frontend.torch:\detokenize{module-cancer_frontend.torch}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}